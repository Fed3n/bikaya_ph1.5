Documentazione relativa alla fase 1 del Bikaya Project di Federico De Marchi, Stefano Sgarzi, Manuel Vannini.

Breve spiegazione generale delle scelte implementative e delle implementazioni non banali di alcune funzioni.

######

Il progetto è strutturato in modo da provare ad essere il più modulare possibile (anche in vista della mole di codice che verrà aggiunta per il completamento della fase 2) ed è quindi diviso in un file init, dedicato alle funzioni di inizializzazione di aree di memoria e processi, un file scheduler, in cui sono presenti la funzione schedule() e tutte le funzioni relative alla gestione della ready queue, un file handler, in cui sono definite le funzioni di handling delle eccezioni, e infine i file interrupt e syscall che contengono le funzioni richiamate dagli handler rispettivi. Sono inoltre presenti i precedenti file relativi alla gestione dei PCB, un file auxfun contenente funzioni ausiliarie memset e memcpy e i file di dichiarazioni di costanti.

In questa fase si è dovuto iniziare a distinguere visibilmente i comportamenti da adottare in base all'architettura per cui va compilato il progetto. A questo riguardo la nostra scelta è stata di evitare il più possibile blocchi del tipo #ifdef TARGET *codice* #endif nel codice principale e di rilegare tutto all'utilizzo di macro universali, definite specificamente per ciascuna delle due architetture nel file const.h. Esempi di queste macro sono per gli accessi a campi della struttura state_t o la quantità di riduzione/incremento del program counter in seguito a specifici eventi.

#MAIN E INIZIALIZZAZIONE#
Per prima cosa vengono inizializzate le exception area. La funzione initAreas semplicemente chiama initExcarea per ogni new area dando in input l'area di memoria di interesse castata a puntatore a state_t e l'entry point della funzione di handling e initExcarea va semplicemente a popolare i campi di interesse nella area in input come da istruzioni. Vengono poi inizializzati i PCB con la funzione già definita nella fase precedente e inizializzati i 3 processi di test con la funzione initProcess_KM. initProcess_KM inizializza un pcb_t a processo in kernel mode con interrupt tutti disabilitati ad esclusione dei timer, con entry point alla funzione rispettiva e con un intero n che è sia la posizione in RAM che la priorità attribuita al processo. Questa fase di inizializzazione degli state_t è risultata molto meno intuitiva per uMPS che per uARM. Mentre per uARM le macro erano tutte definite chiaramente e i comportamenti erano prevedibili, per uMPS si sono dovute definire le macro per gli indirizzi delle aree e per il setting dei bit. Inoltre vi erano due comportamenti specifici per uMPS poco intuitivi senza una lettura approfondita del manuale, il dover inizializzare anche il reg_t9 all'entry point (in aggiunta al program counter) e il dover settare il bit IEp invece del bit IEc per l'abilitazione degli interrupt.

#SCHEDULER#
Nello scheduler si è scelto di creare una HIDDEN list_head readyQueue_h e una serie di funzioni (che incapsulano quelle già definite per le procQueue) per interagirvi. Gli elementi principali dello scheduler sono un puntatore al processo corrente pcb_t* currentProc e la ready queue di puntatori pcb_t in attesa di prendere il controllo. In aggiunta alle funzioni per la gestione della ready queue, anche le funzioni terminateProc e updatePriority possono essere usate per interfacciarsi allo scheduler e rispettivamente terminano il processo corrente e aggiornano le priorità del processo corrente e di quelli in coda (in questa fase updatePriority viene chiamata solo dal timer interrupt e riporta la priority di currentProc a original_priority e aumenta di un'unità la priority di tutti i processi in coda).
Il cuore dello scheduler è la funzione schedule, che viene chiamata ogni volta che si vuole valutare quale processo mandare in esecuzione. In questa fase si reinserisce banalmente nella coda di priorità il currentProc in caso sia ancora presente e poi estrae il primo processo in coda, lo assegna come currentProc e lo carica sul processore con una LDST. Importante notare che nella nostra implementazione delle code di processi la funzione insertProcQ a parità di priorità tra il processo che sta venendo inserito e quelli già in coda mette per primo quello in inserimento. In questo modo se l'eccezione che porta all'interruzione dell'esecuzione non aggiunge processi o modifica le priorità, si è sicuri che richiamando schedule il processo che era prima in esecuzione vi tornerà.
Sperimentalmente se chiamando schedule non ci sono processi da mandare in esecuzione lo scheduler carica uno stato che chiama una WAIT con interrupt abilitati. Probabilmente in questa fase sarebbe bastato chiamare HALT, ma sembrava più sensato che lo scheduler rimanesse in attesa di nuovi processi invece di fermare la macchina (anche se ovviamente in questa fase sappiamo che non verranno attivati nuovi processi).

#SYSCALL#
Le system call vengono gestite da una funzione principale chiamata syscall_handler che si occupa di salvare l'old state e di  recuperare i valori relativi al numero della sistem call ed ai parametri dai registri dell' oldarea dedicata. Viene poi chiamata la system call corrispondere con i propri parametri. 
Nonostante l'unica system call da gestire in questa fase non presenta parametri è stato ugualmente implementato il meccanismo di recupero parametri delle systemcall (vengono infatti memorizzati in variabili apposite all'interno dell'handler). La scelta è stata fatta per avere una maggiore completezza del codice ed in prospettiva alla fase successiva.
Nel file dedicato sono invece presenti le system call, in questo fase solo la numero tre, che si occupa di terminare il processo corrente e di rimuovere tutti i suoi figli dalla readyQueue. La funzione gestisce le due fasi separatamente: prima viene effettuata la rimozione dei figli tramite una funzione ricorsiva ausiliaria, successivamente viene terminato il processo padre e richiamato lo scheduler.

#INTERRUPT#
Gli Interrupt vengono gestiti da una funzione di handling chiamata interrupt_handler. Per questa fase si è scelto di gestire gli interrupt con il Bus Interval Timer. Il richiamo agli altri interrupt è previsto e ne è stato scritto uno scheletro progettuale, che verrà implementato nelle fasi sucessive.
È stato implementato un controllo per la linea di Interrupt, anche se per questa fase non vengono utilizzati tutti. 
Durante l'inizializzazione dell'Interrupt avviene un decremento di una parola nel Program Counter su uarm, dopodiché si salva lo stato della OLDAREA attraverso l'utilizzo di una funzione memcpy.
Dopo aver controllato l'origine dell'Interrupt, viene richiamata la funzione updatePriority() che riporta la priorità del processo corrente allo stato originale e aumenta quella degli altri processi.
Il primo Timer per il richiamo degli interrupt avviene a priori della prima schedulazione. Durante l'esecuzione di ogni Interrupt, il timer viene reimpostato, successivamente viene richiamato lo scheduler.